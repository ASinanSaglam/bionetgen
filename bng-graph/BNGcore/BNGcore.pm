# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.4
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

package BNGcore;
use base qw(Exporter);
use base qw(DynaLoader);
package BNGcorec;
bootstrap BNGcore;
package BNGcore;
@EXPORT = qw();

# ---------- BASE METHODS -------------

package BNGcore;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub FIRSTKEY { }

sub NEXTKEY { }

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    $self->$member_func();
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    $self->$member_func($newval);
}

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package BNGcore;


############# Class : BNGcore::StateType ##############

package BNGcore::StateType;
use overload
    "<" => sub { $_[0]->__lt__($_[1])},
    "==" => sub { $_[0]->__eq__($_[1])},
    "=" => sub { my $class = ref($_[0]); $class->new($_[0]) },
    "fallback" => 1;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( BNGcore );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = BNGcorec::new_StateType(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        BNGcorec::delete_StateType($self);
        delete $OWNER{$self};
    }
}

*get_state_object = *BNGcorec::StateType_get_state_object;
*__eq__ = *BNGcorec::StateType___eq__;
*__lt__ = *BNGcorec::StateType___lt__;
*less = *BNGcorec::StateType_less;
*check_state = *BNGcorec::StateType_check_state;
*get_label = *BNGcorec::StateType_get_label;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : BNGcore::NullStateType ##############

package BNGcore::NullStateType;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( BNGcore::StateType BNGcore );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = BNGcorec::new_NullStateType(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        BNGcorec::delete_NullStateType($self);
        delete $OWNER{$self};
    }
}

*get_state_object = *BNGcorec::NullStateType_get_state_object;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : BNGcore::LabelStateType ##############

package BNGcore::LabelStateType;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( BNGcore::StateType BNGcore );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = BNGcorec::new_LabelStateType(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        BNGcorec::delete_LabelStateType($self);
        delete $OWNER{$self};
    }
}

*get_state_object = *BNGcorec::LabelStateType_get_state_object;
*add_state = *BNGcorec::LabelStateType_add_state;
*check_state = *BNGcorec::LabelStateType_check_state;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : BNGcore::BondStateType ##############

package BNGcore::BondStateType;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( BNGcore::LabelStateType BNGcore );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = BNGcorec::new_BondStateType(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        BNGcorec::delete_BondStateType($self);
        delete $OWNER{$self};
    }
}

*get_state_object = *BNGcorec::BondStateType_get_state_object;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : BNGcore::CounterStateType ##############

package BNGcore::CounterStateType;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( BNGcore::StateType BNGcore );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = BNGcorec::new_CounterStateType(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        BNGcorec::delete_CounterStateType($self);
        delete $OWNER{$self};
    }
}

*get_state_object = *BNGcorec::CounterStateType_get_state_object;
*check_state = *BNGcorec::CounterStateType_check_state;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : BNGcore::State ##############

package BNGcore::State;
use overload
    "==" => sub { $_[0]->__eq__($_[1])},
    "=" => sub { my $class = ref($_[0]); $class->new($_[0]) },
    "fallback" => 1;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( BNGcore );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = BNGcorec::new_State(@_);
    bless $self, $pkg if defined($self);
}

*clone = *BNGcorec::State_clone;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        BNGcorec::delete_State($self);
        delete $OWNER{$self};
    }
}

*get_type = *BNGcorec::State_get_type;
*set_state = *BNGcorec::State_set_state;
*add = *BNGcorec::State_add;
*increment = *BNGcorec::State_increment;
*decrement = *BNGcorec::State_decrement;
*get_label = *BNGcorec::State_get_label;
*get_BNG2_string = *BNGcorec::State_get_BNG2_string;
*__eq__ = *BNGcorec::State___eq__;
*less = *BNGcorec::State_less;
*is_wildcard = *BNGcorec::State_is_wildcard;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : BNGcore::NullState ##############

package BNGcore::NullState;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( BNGcore::State BNGcore );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = BNGcorec::new_NullState(@_);
    bless $self, $pkg if defined($self);
}

*clone = *BNGcorec::NullState_clone;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        BNGcorec::delete_NullState($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : BNGcore::LabelState ##############

package BNGcore::LabelState;
use overload
    "==" => sub { $_[0]->__eq__($_[1])},
    "=" => sub { my $class = ref($_[0]); $class->new($_[0]) },
    "fallback" => 1;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( BNGcore::State BNGcore );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = BNGcorec::new_LabelState(@_);
    bless $self, $pkg if defined($self);
}

*clone = *BNGcorec::LabelState_clone;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        BNGcorec::delete_LabelState($self);
        delete $OWNER{$self};
    }
}

*set_state = *BNGcorec::LabelState_set_state;
*get_label = *BNGcorec::LabelState_get_label;
*get_BNG2_string = *BNGcorec::LabelState_get_BNG2_string;
*__eq__ = *BNGcorec::LabelState___eq__;
*less = *BNGcorec::LabelState_less;
*is_wildcard = *BNGcorec::LabelState_is_wildcard;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : BNGcore::BondState ##############

package BNGcore::BondState;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( BNGcore::LabelState BNGcore );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = BNGcorec::new_BondState(@_);
    bless $self, $pkg if defined($self);
}

*clone = *BNGcorec::BondState_clone;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        BNGcorec::delete_BondState($self);
        delete $OWNER{$self};
    }
}

*get_label = *BNGcorec::BondState_get_label;
*get_BNG2_string = *BNGcorec::BondState_get_BNG2_string;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : BNGcore::CounterState ##############

package BNGcore::CounterState;
use overload
    "==" => sub { $_[0]->__eq__($_[1])},
    "=" => sub { my $class = ref($_[0]); $class->new($_[0]) },
    "fallback" => 1;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( BNGcore::State BNGcore );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = BNGcorec::new_CounterState(@_);
    bless $self, $pkg if defined($self);
}

*clone = *BNGcorec::CounterState_clone;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        BNGcorec::delete_CounterState($self);
        delete $OWNER{$self};
    }
}

*set_state = *BNGcorec::CounterState_set_state;
*add = *BNGcorec::CounterState_add;
*increment = *BNGcorec::CounterState_increment;
*decrement = *BNGcorec::CounterState_decrement;
*__eq__ = *BNGcorec::CounterState___eq__;
*less = *BNGcorec::CounterState_less;
*get_label = *BNGcorec::CounterState_get_label;
*get_BNG2_string = *BNGcorec::CounterState_get_BNG2_string;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : BNGcore::NodeType ##############

package BNGcore::NodeType;
use overload
    "<" => sub { $_[0]->__lt__($_[1])},
    "==" => sub { $_[0]->__eq__($_[1])},
    "=" => sub { my $class = ref($_[0]); $class->new($_[0]) },
    "fallback" => 1;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( BNGcore );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = BNGcorec::new_NodeType(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        BNGcorec::delete_NodeType($self);
        delete $OWNER{$self};
    }
}

*__eq__ = *BNGcorec::NodeType___eq__;
*less = *BNGcorec::NodeType_less;
*__lt__ = *BNGcorec::NodeType___lt__;
*get_type_name = *BNGcorec::NodeType_get_type_name;
*get_parent_type = *BNGcorec::NodeType_get_parent_type;
*get_state_type = *BNGcorec::NodeType_get_state_type;
*get_label = *BNGcorec::NodeType_get_label;
*get_instance_flag = *BNGcorec::NodeType_get_instance_flag;
*set_instance_flag = *BNGcorec::NodeType_set_instance_flag;
*check_state = *BNGcorec::NodeType_check_state;
*add_edges_in = *BNGcorec::NodeType_add_edges_in;
*add_edges_out = *BNGcorec::NodeType_add_edges_out;
*edges_in_begin = *BNGcorec::NodeType_edges_in_begin;
*edges_in_end = *BNGcorec::NodeType_edges_in_end;
*edges_out_begin = *BNGcorec::NodeType_edges_out_begin;
*edges_out_end = *BNGcorec::NodeType_edges_out_end;
*get_BNG2_string = *BNGcorec::NodeType_get_BNG2_string;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : BNGcore::EntityType ##############

package BNGcore::EntityType;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( BNGcore::NodeType BNGcore );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = BNGcorec::new_EntityType(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        BNGcorec::delete_EntityType($self);
        delete $OWNER{$self};
    }
}

*get_BNG2_string = *BNGcorec::EntityType_get_BNG2_string;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : BNGcore::BondType ##############

package BNGcore::BondType;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( BNGcore::NodeType BNGcore );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = BNGcorec::new_BondType(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        BNGcorec::delete_BondType($self);
        delete $OWNER{$self};
    }
}

*get_BNG2_string = *BNGcorec::BondType_get_BNG2_string;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : BNGcore::Node ##############

package BNGcore::Node;
use overload
    "==" => sub { $_[0]->__eq__($_[1])},
    "=" => sub { my $class = ref($_[0]); $class->new($_[0]) },
    "fallback" => 1;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( BNGcore );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = BNGcorec::new_Node(@_);
    bless $self, $pkg if defined($self);
}

*clone = *BNGcorec::Node_clone;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        BNGcorec::delete_Node($self);
        delete $OWNER{$self};
    }
}

*get_type = *BNGcorec::Node_get_type;
*get_state = *BNGcorec::Node_get_state;
*get_index = *BNGcorec::Node_get_index;
*set_state = *BNGcorec::Node_set_state;
*set_index = *BNGcorec::Node_set_index;
*in_degree = *BNGcorec::Node_in_degree;
*out_degree = *BNGcorec::Node_out_degree;
*add_edge_in = *BNGcorec::Node_add_edge_in;
*add_edge_out = *BNGcorec::Node_add_edge_out;
*delete_edge_in = *BNGcorec::Node_delete_edge_in;
*delete_edge_out = *BNGcorec::Node_delete_edge_out;
*__eq__ = *BNGcorec::Node___eq__;
*less = *BNGcorec::Node_less;
*less_by_index = *BNGcorec::Node_less_by_index;
*validate_typing = *BNGcorec::Node_validate_typing;
*get_label = *BNGcorec::Node_get_label;
*get_BNG2_string = *BNGcorec::Node_get_BNG2_string;
*edges_in_begin = *BNGcorec::Node_edges_in_begin;
*edges_in_end = *BNGcorec::Node_edges_in_end;
*edges_out_begin = *BNGcorec::Node_edges_out_begin;
*edges_out_end = *BNGcorec::Node_edges_out_end;
*find_in_edge = *BNGcorec::Node_find_in_edge;
*find_out_edge = *BNGcorec::Node_find_out_edge;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : BNGcore::PatternGraph ##############

package BNGcore::PatternGraph;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( BNGcore );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = BNGcorec::new_PatternGraph(@_);
    bless $self, $pkg if defined($self);
}

*clone = *BNGcorec::PatternGraph_clone;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        BNGcorec::delete_PatternGraph($self);
        delete $OWNER{$self};
    }
}

*copy_and_get_map = *BNGcorec::PatternGraph_copy_and_get_map;
*build_tree_graph = *BNGcorec::PatternGraph_build_tree_graph;
*add_node = *BNGcorec::PatternGraph_add_node;
*delete_node = *BNGcorec::PatternGraph_delete_node;
*add_edge = *BNGcorec::PatternGraph_add_edge;
*delete_edge = *BNGcorec::PatternGraph_delete_edge;
*set_node_state = *BNGcorec::PatternGraph_set_node_state;
*is_canonical = *BNGcorec::PatternGraph_is_canonical;
*reset_index = *BNGcorec::PatternGraph_reset_index;
*get_BNG2_string = *BNGcorec::PatternGraph_get_BNG2_string;
*get_label = *BNGcorec::PatternGraph_get_label;
*print = *BNGcorec::PatternGraph_print;
*begin = *BNGcorec::PatternGraph_begin;
*end = *BNGcorec::PatternGraph_end;
*size = *BNGcorec::PatternGraph_size;
*empty = *BNGcorec::PatternGraph_empty;
*gather_subtree = *BNGcorec::PatternGraph_gather_subtree;
*gather_connected = *BNGcorec::PatternGraph_gather_connected;
*validate = *BNGcorec::PatternGraph_validate;
*validate_instance_types = *BNGcorec::PatternGraph_validate_instance_types;
*check_embedding = *BNGcorec::PatternGraph_check_embedding;
*contains_instance_nodes = *BNGcorec::PatternGraph_contains_instance_nodes;
*quick_merge = *BNGcorec::PatternGraph_quick_merge;
*split_connected = *BNGcorec::PatternGraph_split_connected;
*splice = *BNGcorec::PatternGraph_splice;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : BNGcore::Map ##############

package BNGcore::Map;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( BNGcore );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = BNGcorec::new_Map(@_);
    bless $self, $pkg if defined($self);
}

*clone = *BNGcorec::Map_clone;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        BNGcorec::delete_Map($self);
        delete $OWNER{$self};
    }
}

*mapf = *BNGcorec::Map_mapf;
*invert = *BNGcorec::Map_invert;
*image = *BNGcorec::Map_image;
*find = *BNGcorec::Map_find;
*insert = *BNGcorec::Map_insert;
*erase = *BNGcorec::Map_erase;
*get_source_graph = *BNGcorec::Map_get_source_graph;
*get_target_graph = *BNGcorec::Map_get_target_graph;
*set_source_graph = *BNGcorec::Map_set_source_graph;
*set_target_graph = *BNGcorec::Map_set_target_graph;
*begin = *BNGcorec::Map_begin;
*end = *BNGcorec::Map_end;
*size = *BNGcorec::Map_size;
*empty = *BNGcorec::Map_empty;
*quick_merge = *BNGcorec::Map_quick_merge;
*copy_map_and_target = *BNGcorec::Map_copy_map_and_target;
*print = *BNGcorec::Map_print;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : BNGcore::Transformation ##############

package BNGcore::Transformation;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( BNGcore );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = BNGcorec::new_Transformation(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        BNGcorec::delete_Transformation($self);
        delete $OWNER{$self};
    }
}

*clone = *BNGcorec::Transformation_clone;
*clone_and_remap = *BNGcorec::Transformation_clone_and_remap;
*transform = *BNGcorec::Transformation_transform;
*remap = *BNGcorec::Transformation_remap;
*print = *BNGcorec::Transformation_print;
*get_center = *BNGcorec::Transformation_get_center;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : BNGcore::AddNode ##############

package BNGcore::AddNode;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( BNGcore::Transformation BNGcore );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = BNGcorec::new_AddNode(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        BNGcorec::delete_AddNode($self);
        delete $OWNER{$self};
    }
}

*clone = *BNGcorec::AddNode_clone;
*clone_and_remap = *BNGcorec::AddNode_clone_and_remap;
*transform = *BNGcorec::AddNode_transform;
*remap = *BNGcorec::AddNode_remap;
*print = *BNGcorec::AddNode_print;
*get_center = *BNGcorec::AddNode_get_center;
*get_pointer = *BNGcorec::AddNode_get_pointer;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : BNGcore::DeleteNode ##############

package BNGcore::DeleteNode;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( BNGcore::Transformation BNGcore );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = BNGcorec::new_DeleteNode(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        BNGcorec::delete_DeleteNode($self);
        delete $OWNER{$self};
    }
}

*clone = *BNGcorec::DeleteNode_clone;
*clone_and_remap = *BNGcorec::DeleteNode_clone_and_remap;
*transform = *BNGcorec::DeleteNode_transform;
*remap = *BNGcorec::DeleteNode_remap;
*print = *BNGcorec::DeleteNode_print;
*get_center = *BNGcorec::DeleteNode_get_center;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : BNGcore::AddEdge ##############

package BNGcore::AddEdge;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( BNGcore::Transformation BNGcore );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = BNGcorec::new_AddEdge(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        BNGcorec::delete_AddEdge($self);
        delete $OWNER{$self};
    }
}

*clone = *BNGcorec::AddEdge_clone;
*clone_and_remap = *BNGcorec::AddEdge_clone_and_remap;
*transform = *BNGcorec::AddEdge_transform;
*remap = *BNGcorec::AddEdge_remap;
*print = *BNGcorec::AddEdge_print;
*get_center = *BNGcorec::AddEdge_get_center;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : BNGcore::AddBond ##############

package BNGcore::AddBond;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( BNGcore::Transformation BNGcore );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = BNGcorec::new_AddBond(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        BNGcorec::delete_AddBond($self);
        delete $OWNER{$self};
    }
}

*clone = *BNGcorec::AddBond_clone;
*clone_and_remap = *BNGcorec::AddBond_clone_and_remap;
*transform = *BNGcorec::AddBond_transform;
*remap = *BNGcorec::AddBond_remap;
*print = *BNGcorec::AddBond_print;
*get_center = *BNGcorec::AddBond_get_center;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : BNGcore::DeleteEdge ##############

package BNGcore::DeleteEdge;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( BNGcore::Transformation BNGcore );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = BNGcorec::new_DeleteEdge(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        BNGcorec::delete_DeleteEdge($self);
        delete $OWNER{$self};
    }
}

*clone = *BNGcorec::DeleteEdge_clone;
*clone_and_remap = *BNGcorec::DeleteEdge_clone_and_remap;
*transform = *BNGcorec::DeleteEdge_transform;
*remap = *BNGcorec::DeleteEdge_remap;
*print = *BNGcorec::DeleteEdge_print;
*get_center = *BNGcorec::DeleteEdge_get_center;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : BNGcore::DeleteBond ##############

package BNGcore::DeleteBond;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( BNGcore::Transformation BNGcore );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = BNGcorec::new_DeleteBond(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        BNGcorec::delete_DeleteBond($self);
        delete $OWNER{$self};
    }
}

*clone = *BNGcorec::DeleteBond_clone;
*clone_and_remap = *BNGcorec::DeleteBond_clone_and_remap;
*transform = *BNGcorec::DeleteBond_transform;
*remap = *BNGcorec::DeleteBond_remap;
*print = *BNGcorec::DeleteBond_print;
*get_center = *BNGcorec::DeleteBond_get_center;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : BNGcore::ChangeState ##############

package BNGcore::ChangeState;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( BNGcore::Transformation BNGcore );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = BNGcorec::new_ChangeState(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        BNGcorec::delete_ChangeState($self);
        delete $OWNER{$self};
    }
}

*clone = *BNGcorec::ChangeState_clone;
*clone_and_remap = *BNGcorec::ChangeState_clone_and_remap;
*transform = *BNGcorec::ChangeState_transform;
*remap = *BNGcorec::ChangeState_remap;
*print = *BNGcorec::ChangeState_print;
*get_center = *BNGcorec::ChangeState_get_center;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : BNGcore::DeleteSubtree ##############

package BNGcore::DeleteSubtree;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( BNGcore::Transformation BNGcore );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = BNGcorec::new_DeleteSubtree(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        BNGcorec::delete_DeleteSubtree($self);
        delete $OWNER{$self};
    }
}

*clone = *BNGcorec::DeleteSubtree_clone;
*clone_and_remap = *BNGcorec::DeleteSubtree_clone_and_remap;
*transform = *BNGcorec::DeleteSubtree_transform;
*remap = *BNGcorec::DeleteSubtree_remap;
*print = *BNGcorec::DeleteSubtree_print;
*get_center = *BNGcorec::DeleteSubtree_get_center;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : BNGcore::DeleteConnected ##############

package BNGcore::DeleteConnected;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( BNGcore::Transformation BNGcore );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = BNGcorec::new_DeleteConnected(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        BNGcorec::delete_DeleteConnected($self);
        delete $OWNER{$self};
    }
}

*clone = *BNGcorec::DeleteConnected_clone;
*clone_and_remap = *BNGcorec::DeleteConnected_clone_and_remap;
*transform = *BNGcorec::DeleteConnected_transform;
*remap = *BNGcorec::DeleteConnected_remap;
*print = *BNGcorec::DeleteConnected_print;
*get_center = *BNGcorec::DeleteConnected_get_center;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : BNGcore::NodeFunction ##############

package BNGcore::NodeFunction;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( BNGcore );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = BNGcorec::new_NodeFunction(@_);
    bless $self, $pkg if defined($self);
}

*clone = *BNGcorec::NodeFunction_clone;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        BNGcorec::delete_NodeFunction($self);
        delete $OWNER{$self};
    }
}

*map = *BNGcorec::NodeFunction_map;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : BNGcore::ConstantNodeFunction ##############

package BNGcore::ConstantNodeFunction;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( BNGcore::NodeFunction BNGcore );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = BNGcorec::new_ConstantNodeFunction(@_);
    bless $self, $pkg if defined($self);
}

*clone = *BNGcorec::ConstantNodeFunction_clone;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        BNGcorec::delete_ConstantNodeFunction($self);
        delete $OWNER{$self};
    }
}

*map = *BNGcorec::ConstantNodeFunction_map;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : BNGcore::BondNodeFunction ##############

package BNGcore::BondNodeFunction;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( BNGcore::NodeFunction BNGcore );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = BNGcorec::new_BondNodeFunction(@_);
    bless $self, $pkg if defined($self);
}

*clone = *BNGcorec::BondNodeFunction_clone;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        BNGcorec::delete_BondNodeFunction($self);
        delete $OWNER{$self};
    }
}

*map = *BNGcorec::BondNodeFunction_map;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


# ------- VARIABLE STUBS --------

package BNGcore;

1;
