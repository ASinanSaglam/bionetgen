dt = 1e-7
iterations = 100
r_int = 0.005

sidelen = 0.1 
half_box = sidelen/2 

rxn_rate = 9e10
count_A = 2000

TIME_STEP = dt
TIME_STEP_MAX = 1 * dt
ITERATIONS = iterations
INTERACTION_RADIUS = r_int

EFFECTOR_GRID_DENSITY = 10000

PARTITION_X = [[-half_box - 0.015 TO half_box + 0.015 STEP 0.02]]
PARTITION_Y = [[-half_box - 0.015 TO half_box + 0.015 STEP 0.02]]
PARTITION_Z = [[-half_box - 0.015 TO half_box + 0.015 STEP 0.02]]

DEFINE_MOLECULES {
  A { DIFFUSION_CONSTANT_2D = 0 }
  B { DIFFUSION_CONSTANT_2D = 0 }
  C { DIFFUSION_CONSTANT_2D = 0 }
  D { DIFFUSION_CONSTANT_2D = 0 }
}



DEFINE_REACTIONS {

	/*The following examples of reactions are usable individually. You can un-comment them and run them in MCell. However, not all of them will work together, but some combinations will. Remember that if you use reactions in combinations you need to change the names so that no two reactions have the same reference name e.g. my_rxn. Also you will need to change the REACTION_DATA section appropriately if you wish to count the combined reactions.*/

	//A', @  reactant_surface' -> B, [rxn_rate]:my_rxn
	//A', + B', -> C', [rxn_rate]

	/*In this reaction, molecule A undergoes a reaction at the surface class, reactant_surface, to produce B. 'reactant_surface' is a surface class which is applied to 
	all elements of the small_box object. The ticks denote that the volume molecule A reacts only with the FRONT of the surface
	class, in this example that is the outside of the small_box. 'reactant_surface' has the property that is it reflective to both A and B;
	therefore, neither can diffuse across it. In the REACTION_DATA output section the amount of A and B inside the small_box is counted. 
	These data show that only B exists inside the box and cannot escape since it matches the total count of B.*/

	/*A' @ reactant_surface' -> A, [rxn_rate]:my_rxn*/

	/*This is similar to the above reaction except that A is moved inside of the small box by the reactant_surface*/

	/*A' @ reactant_surface' -> D'' [rxn_rate]:my_rxn*/
	
	/*In this reaction, molecule A reacts at the FRONT of reactant surface and produces D (a surface molecule). The orientation of D is random since
	it is in a different reaction-class (denoted by the '' vs ').*/ 

	A', + C; -> B; [rxn_rate]:my_rxn

	/*A reacts with the TOP of C (facing the FRONT) and causes A to be destroyed and C to flip. This reaction is best seen in DReAMM using a glyph
	which has an orientation (such as an arrow).*/

	/*C' -> C, [rxn_rate]:my_rxn*/

	/*C changes orientation on the surface at the given rate. This does not mean that it flips from TOP-FRONT to TOP-BACK and stops; rather, it flips
	  both orientations with equal likelihood (TOP-FRONT to TOP-BACK and TOP-BACK to TOP-FRONT) since a surface is not given as a reference.*/

 	/*C' @ reactant_surface' -> C, [rxn_rate]:my_rxn*/

	/*C changes orientation from TOP-FRONT to TOP-BACK only (only C's which are aligned with the reactant_surface may undergo this reaction).*/	

	/*A' + C' -> C' + B,, [rxn_rate]:my_rxn*/

	/*A reacts with the TOP of C and causes B to be produced from both the TOP and BOTTOM of C since it is in a different group.*/

	/*A'' + C' -> C, + B,, [rxn_rate]:my_rxn*/

	/*This reaction is more complex. A and B are in a group. C is in a group with itself (reactant-C and product-C). A and B are not in a group
	with C. Since A is not in the same group with C, alignment and opposition do not apply. Therefore, A can react with either the TOP or BOTTOM
	of C. When this reaction occurs two things happen. First, since C-product and C-reactant are in the same group and opposed, C-product is
	produced in the opposite orientation to C-reactant e.g. if C-reactant is TOP-FRONT C-product will be TOP-BACK. B is produced in this reaction.
	Since B is not in a group with C it can be produced at either the TOP or BOTTOM of C. B is in a group with A and opposed. Therefore, while B
	can be produced at either the TOP or BOTTOM of C it will only be produced at the side which is opposite to that which reacted with A. If A
	reacts with the TOP of C, B is produced from the BOTTOM of C. If A reacts with the BOTTOM of C, B is produced at the TOP of C.*/
}


box BOX { CORNERS = [-half_box,-half_box,-half_box], [half_box,half_box,half_box] }

small_box BOX {
	CORNERS = [-half_box*0.5,-half_box*0.5,-half_box*0.5], [half_box*0.5,half_box*0.5,half_box*0.5] 
	DEFINE_SURFACE_REGIONS {
		r1 {
			ELEMENT_LIST = [ALL_ELEMENTS] 
		//	SURFACE_CLASS = reactant_surface
			MOLECULE_DENSITY { C', = 10000 } /*C is placed on the region r1 in the TOP-FRONT orientation*/
		}
		r2 {
			ELEMENT_LIST = [ALL_ELEMENTS] 
		//	SURFACE_CLASS = reactant_surface
			MOLECULE_DENSITY { A', = 1000 } /*C is placed on the region r1 in the TOP-FRONT orientation*/
		}
	}
}



INSTANTIATE microdomain OBJECT {

	system_box OBJECT box{}
	small_box OBJECT small_box{}
	

}

VIZ_OUTPUT {

	MODE = DREAMM_V3
	
	FILENAME ="rxn_class"

	MOLECULES {
		NAME_LIST {ALL_MOLECULES}
		TIME_POINTS {ALL_DATA @ ALL_TIMES}
	}

	MESHES {
		NAME_LIST {ALL_MESHES}
		TIME_POINTS {ALL_DATA @ [0]}
	}
}

REACTION_DATA_OUTPUT {
        STEP = 1*dt
	{COUNT[A, WORLD]} => "./reaction_data/A.dat"
	{COUNT[B, WORLD]} => "./reaction_data/B.dat"
	{COUNT[C, WORLD]} => "./reaction_data/C.dat"
	{COUNT[D, WORLD]} => "./reaction_data/D.dat"
	{COUNT[A, microdomain.small_box]} => "./reaction_data/A_inside.dat"
	{COUNT[B, microdomain.small_box]} => "./reaction_data/B_inside.dat"
	{COUNT[my_rxn, WORLD]} => "./reaction_data/my_rxn.dat"
}


